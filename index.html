<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Final Project: Music to My Ears</title>
</head>
<body>

<h1>Final Project: Music to My Ears</h1>

<h3>Melina Daniilidis, Garrett Kirsch, Nikolaos Rapanis</h3>

<h2>Results</h2>
<p>Our final device, <strong>Music to My Ears</strong>, successfully reads live MIDI input from an electric keyboard, allows the user to shift the melody up or down by a desired number of semitones using two buttons, and replays the transposed melody through a buzzer with accurate timing. The system also displays the inputted and shifted notes on a color LCD screen for easy visual feedback. It uses an ATmega328PB microcontroller to manage real-time MIDI UART communication, PWM audio output, and user input simultaneously. We implemented a full graphics library for musical notation display, wrote custom drivers for the buzzer and screen, and built a simple cardboard housing to organize the components neatly on the workbench. In the end, we delivered a working, responsive prototype that achieves the original project goal: enabling musicians to quickly and easily transpose melodies without needing music theory knowledge.</p>

<h2>Video Demonstration</h2>
<iframe src="https://drive.google.com/file/d/1ngGfAtsrGlymLhpcTdSK29lmTKguykDP/preview" width="640" height="480" allow="autoplay"></iframe>

<h2>Photo Album</h2>
<p>+++ Include photos of your device from a few angles, showing both exterior and interior. +++</p>

<h2>Software Requirements Specification Validation</h2>
<table border="1">
<tr><th>ID</th><th>Description</th></tr>
<tr><td>SRS-01</td><td>The notes from the input recording shall be cleaned and parsed accurately based on their frequencies.</td></tr>
<tr><td>SRS-02</td><td>The screen will show the number of times the shift button has been pressed, so the user has a visual indication of how many semitones they want to shift by.</td></tr>
<tr><td>SRS-03</td><td>The transposition algorithm will correctly shift each note of the inputted melody by the user's desired amount of semitones.</td></tr>
<tr><td>SRS-04</td><td>The screen should correctly display the names of the notes from the transposed melody in a readable format.</td></tr>
<tr><td>SRS-05</td><td>The speaker shall correctly output the transposition melody.</td></tr>
<tr><td>SRS-06</td><td>The screen should display the transposed notes and the speaker will play the frequencies of the transposed notes simultaneously.</td></tr>
</table>

<p><strong>What worked well:</strong> We were able to read MIDI input reliably, store melodies, shift notes by a user-defined semitone amount, and display both the original and shifted notes on the LCD in real-time.</p>
<p><strong>What changed:</strong> We changed from selecting input/output keys to simple up/down semitone shifting to simplify design and user experience.</p>
<p><strong>New Requirements Added:</strong> Added button-controlled shifting and shift-count display.</p>
<p><strong>Challenges:</strong> Handling interrupts with UART MIDI input; resolved by using polling temporarily, then fixing the ISR issues for final demo.</p>
<p><strong>Validation:</strong><br>
SRS-01: Oscilloscope proof of MIDI parsing.<br>
SRS-06: Video proof of the screen displaying transposed notes.</p>

<h2>Hardware Requirements Specification Validation</h2>
<table border="1">
<tr><th>ID</th><th>Description</th></tr>
<tr><td>HRS-01</td><td>A mini electric piano will be used to provide inputs (i.e. music) processed by the ATmega.</td></tr>
<tr><td>HRS-02</td><td>There will be two buttons to choose the shift amount (up/down) by a semitone for each press.</td></tr>
<tr><td>HRS-03</td><td>A screen will display the input key, output key, input octave, and output octave of the music.</td></tr>
</table>

<p><strong>What worked well:</strong> The UART MIDI circuit was stable after bypassing the optoisolator. LCD and buzzer drivers functioned reliably. Button presses worked correctly using interrupts.</p>
<p><strong>What changed:</strong> We switched to a separate buzzer system since the piano lacked a built-in speaker, and simplified to a single speaker.</p>
<p><strong>Challenges:</strong> MIDI optoisolator did not work, likely faulty. We decided to bypass it with no problems observed.</p>
<p><strong>Validation:</strong><br>
HRS-01: Video showing MIDI input live with UART printout.<br>
HRS-02: Buttons tested and working for shift amount changes.</p>

<h2>Reflection</h2>
<p><strong>What did we learn?</strong> We learned how to integrate multiple subsystems (UART MIDI, PWM audio, LCD graphics) on an embedded platform, and how to adapt around hardware limitations.</p>

<p><strong>What went well?</strong> Graphics, UART parsing, and note shifting all integrated cleanly, and the buzzer output matched expectations. Simplifying the user interface greatly helped usability.</p>

<p><strong>What accomplishments are we proud of?</strong> Building a real-time MIDI-driven system with custom drivers, achieving the original functionality despite setbacks.</p>

<p><strong>What did we gain?</strong> Hands-on embedded integration experience, deeper understanding of UART+timing conflicts, and better design flexibility.</p>

<p><strong>Did we have to change our approach?</strong> Yes, we switched from "key-to-key" transposition to simple semitone shifting, removing the need for user key input validation.</p>

<p><strong>What could have been done differently?</strong> Building our own mock keyboard (with switches + resistive divider + ADC) would have avoided delays from waiting for external parts.</p>

<p><strong>Unexpected obstacles?</strong> The MIDI optoisolator setup failed. After removing it, the circuit still functioned correctly without signal loss.</p>

<p><strong>Next steps?</strong> Adding polyphonic input support (chords) would make the system much more powerful for real musical applications.</p>

</body>
</html>
